# Система отслеживания успеваемости в университете на блокчейне

## Обзор
Децентрализованное блокчейн-приложение для отслеживания успеваемости студентов университета, управления курсами и аналитики.

## Функции
- Контроль доступа на основе ролей (Администратор, Преподаватель, Студент)
- Управление курсами
- Отслеживание оценок и посещаемости
- Управление расписанием
- Статистика успеваемости

## Описание функций

### UniversityAccessControl.sol
- **assignRole**: Назначает определенную роль учетной записи.
- **addUser**: Добавляет пользователя с указанной ролью.
- **getRole**: Получает роль определенной учетной записи.
- **hasRole**: Проверяет, имеет ли учетная запись определенную роль.

### CourseManagement.sol
- **createNewCourse**: Позволяет администратору создать новый курс с назначенным преподавателем.

### GradeManagement.sol
- **recordGrade**: Записывает оценку для студента по определенному курсу.
- **markAttendance**: Отмечает посещаемость студента по определенному курсу.

### ScheduleManagement.sol
- **createSchedule**: Создает расписание для курса.
- **getSchedule**: Получает расписание для курса.

### StatisticsTracker.sol
- **initialize**: Инициализирует контракт, вызывая методы инициализации родительских контрактов `GradeManagement` и `ScheduleManagement`.
- **getGrades**: Возвращает список оценок для указанного курса.
- **getAttendance**: Возвращает список посещаемости для указанного курса.
- **getAverageGrade**: Вычисляет и возвращает среднюю оценку для указанного курса. Этот метод позволяет преподавателям и администраторам оценивать общую успеваемость студентов по конкретному курсу.
- **getAttendanceRate**: Вычисляет и возвращает процент посещаемости для указанного курса. Этот метод позволяет преподавателям и администраторам отслеживать посещаемость студентов на занятиях.
- **getAverageGradeByStudent**: Вычисляет и возвращает среднюю оценку для указанного студента по указанному курсу. Этот метод позволяет преподавателям и администраторам оценивать индивидуальную успеваемость каждого студента.
- **getAttendanceRateByStudent**: Вычисляет и возвращает процент посещаемости для указанного студента по указанному курсу. Этот метод позволяет преподавателям и администраторам отслеживать индивидуальную посещаемость каждого студента.

## Решение
Проект представляет собой децентрализованное приложение для управления курсами и отслеживания успеваемости студентов на базе блокчейна. Он включает в себя смарт-контракты для управления доступом, курсами, оценками, расписанием и статистикой.

## Установка и настройка

### Настройка окружения
1. Создайте файл `.env` в корневой директории проекта.
2. Добавьте следующие переменные окружения в файл `.env`:
   ```
   INFURA_API_KEY=your_infura_api_key_here
   MAINNET_PRIVATE_KEY=your_mainnet_private_key_here
   ETH_MAINNET_RPC_URL=your_mainnet_rpc_url_here
   ```

### Установка зависимостей
1. Убедитесь, что у вас установлен Node.js и npm.
2. Установите Yarn, если он еще не установлен:
   ```
   npm install --global yarn
   ```
3. Установите зависимости проекта:
   ```
   yarn install
   ```

### Компиляция смарт-контрактов
1. Скомпилируйте контракты с помощью Hardhat:
   ```
   npx hardhat compile
   ```

### Тестирование
1. Запустите тесты для проверки функциональности контрактов:
   ```
   npx hardhat test
   ```

### Развертывание
1. Настройте параметры развертывания в `hardhat.config.js`.
2. Разверните контракты на локальной сети:
   ```
   npx hardhat run deploy/01_deploy_proxy_contracts.js --network localhost
   ```
3. Разверните контракты на основной сети:
   ```
   npx hardhat run deploy/01_deploy_proxy_contracts.js --network mainnet
   ```

## Архитектура смарт-контрактов
- `UniversityAccessControl.sol`: Управляет ролями пользователей
- `CourseManagement.sol`: Обрабатывает создание и регистрацию на курсы
- `GradeManagement.sol`: Управляет оценками и посещаемостью
- `ScheduleManagement.sol`: Обрабатывает расписание курсов
- `StatisticsTracker.sol`: Предоставляет аналитику успеваемости

## Руководство по сборке и запуску

### Сборка
1. Убедитесь, что у вас установлен Node.js и npm.
2. Установите Yarn, если он еще не установлен:
   ```
   npm install --global yarn
   ```
3. Установите зависимости проекта:
   ```
   yarn install
   ```
4. Скомпилируйте смарт-контракты:
   ```
   npx hardhat compile
   ```

### Запуск
1. Запустите локальную сеть Hardhat:
   ```
   npx hardhat node
   ```
2. Разверните контракты на локальной сети:
   ```
   npx hardhat run deploy/01_deploy_proxy_contracts.js --network localhost
   ```
3. Запустите тесты для проверки функциональности:
   ```
   npx hardhat test
   ```

## CI/CD Pipeline

Этот проект использует GitHub Actions для автоматизации процессов тестирования и развертывания. Каждый раз при пуше в ветку `main` или при создании pull request, выполняются следующие шаги:

1. **Сборка проекта**: Устанавливаются зависимости и собирается Docker-образ.
2. **Тестирование**: Запускаются все тесты с использованием `pytest`.
3. **Развертывание**: Проект разворачивается в Docker Swarm с использованием `docker-compose.yml`.

### Запуск локально

Для локального запуска проекта выполните следующие шаги:

1. Инициализируйте Docker Swarm (если еще не сделано):
   ```bash
   docker swarm init
   ```

2. Запустите проект с помощью Docker Compose:
   ```bash
   docker stack deploy --compose-file docker-compose.yml university-blockchain-tracker
   ```

3. Проверьте статус сервисов:
   ```bash
   docker service ls
   ```

Теперь ваше приложение будет доступно на `http://localhost:5000`.

## Непрерывное развертывание
Проект использует GitHub Actions для автоматического развертывания смарт-контрактов на сеть Rinkeby. При каждом пуше в ветку `main` происходит автоматическая компиляция, тестирование и развертывание контрактов.

## Измерение покрытия кода
Покрытие кода измеряется с помощью плагина `solidity-coverage`. Это позволяет убедиться, что все функции смарт-контрактов покрыты тестами и работают корректно.

Для запуска покрытия кода используйте команду:
```
npx hardhat coverage
```

## Статический анализ кода
Для обеспечения безопасности смарт-контрактов используется Mythril, инструмент для статического анализа. Mythril автоматически запускается в процессе CI/CD для проверки контрактов на уязвимости.

Для запуска анализа вручную используйте скрипт:
```
./analyze_contracts.sh
```

### Подробное описание функций и модификаторов в `CourseManagement.sol`

#### Импорт и наследование
- **Импортируемые модули**: 
  - `Initializable` из OpenZeppelin для поддержки обновляемых контрактов.
  - `AccessControl` для управления ролями и правами доступа.
  - `UniversityAccessControl` для дополнительного контроля доступа.

- **Наследование**: 
  - Контракт наследует `Initializable`, `AccessControl` и `UniversityAccessControl`, что позволяет использовать их функциональность.

#### Переменные состояния
- **`struct Course`**: Определяет курс с именем, адресом преподавателя и списком адресов студентов.
- **`mapping(uint256 => Course) courses`**: Хранит курсы по их идентификатору.
- **`uint256 courseCounter`**: Счетчик для отслеживания количества созданных курсов.

#### События
- **`CourseCreated`**: Генерируется при создании нового курса.
- **`StudentEnrolled`**: Генерируется при зачислении студента на курс.

#### Функции
- **`initialize()`**: Инициализирует контракт, настраивая контроль доступа.
- **`createNewCourse(string memory _name, address _teacher)`**: Позволяет администратору создать новый курс, проверяя наличие у преподавателя соответствующей роли.
- **`enrollStudent(uint256 _courseId)`**: Позволяет студенту записаться на курс, проверяя существование курса.
- **`enrollStudentWithConfirmation(uint256 _courseId)`**: Аналогично `enrollStudent`, возможно с дополнительной логикой подтверждения.
- **`confirmEnrollment(uint256 _courseId, address _student)`**: Позволяет преподавателю подтвердить зачисление студента на его курс.

#### Модификаторы и контроль доступа
- **`onlyRole(Role.Admin)`**: Ограничивает доступ к функциям для пользователей с ролью Администратора.
- **`onlyRole(Role.Teacher)`**: Ограничивает доступ к функциям для пользователей с ролью Преподавателя.
- **`onlyRole(Role.Student)`**: Ограничивает доступ к функциям для пользователей с ролью Студента.

## Использование CLI

Для взаимодействия с контрактами через CLI используйте следующие команды:

- **Перечисление функций контракта**:
  ```bash
  python backend/cli.py list-functions <contract_address> <abi>
  ```

- **Вызов функции контракта (только чтение)**:
  ```bash
  python backend/cli.py call <contract_address> <abi> <function_name> <args>
  ```

- **Отправка транзакции для изменения состояния контракта**:
  ```bash
  python backend/cli.py send <contract_address> <abi> <function_name> <args>
  ```

## Использование REST API

Для взаимодействия с контрактами через REST API используйте следующие эндпоинты:

- **Перечисление функций контракта**:
  - URL: `/list-functions`
  - Метод: `POST`
  - Тело запроса: `{ "contract_address": "<contract_address>", "abi": "<abi>" }`

- **Вызов функции контракта (только чтение)**:
  - URL: `/call`
  - Метод: `POST`
  - Тело запроса: `{ "contract_address": "<contract_address>", "abi": "<abi>", "function_name": "<function_name>", "args": [<args>] }`

- **Отправка транзакции для изменения состояния контракта**:
  - URL: `/send`
  - Метод: `POST`
  - Тело запроса: `{ "contract_address": "<contract_address>", "abi": "<abi>", "function_name": "<function_name>", "args": [<args>] }`

Запустите сервер Flask с помощью команды:

```bash
python backend/api.py
```

Теперь ваш сервер будет слушать HTTP-запросы на взаимодействие с контрактами.

## Использование GUI

Для взаимодействия с контрактами через графический интерфейс выполните следующие шаги:

1. Запустите Flask-приложение:
   ```bash
   python backend/app.py
   ```

2. Откройте браузер и перейдите по адресу `http://localhost:5000`.

3. Используйте предоставленную форму для ввода адреса контракта, ABI, имени функции и аргументов.

4. Нажмите на кнопку для вызова функции или отправки транзакции.

Теперь вы можете взаимодействовать с контрактами через удобный веб-интерфейс.